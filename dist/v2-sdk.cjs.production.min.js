'use strict'
function t(t) {
  return t && 'object' == typeof t && 'default' in t ? t.default : t
}
Object.defineProperty(exports, '__esModule', { value: !0 })
var e = t(require('jsbi')),
  n = require('@uniswap/sdk-core'),
  r = t(require('tiny-invariant')),
  o = require('@ethersproject/solidity'),
  u = require('@ethersproject/address'),
  i = {
    1: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',
    4: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',
    5: '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f',
    56: '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73',
    97: '0x6725f303b657a9451d8ba641348b6761a6cc7a17',
    100: '0xA818b4F111Ccac7AA31D0BCc0806d64F2E0737D7',
    137: '0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32'
  },
  a = {
    1: '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f',
    4: '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f',
    5: '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f',
    56: '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5',
    97: '0xd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66',
    100: '0x3f88503e8580ab941773b59034fb4b2a63e86dbc031b3633a925533ad3ed2b93',
    137: '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
  },
  c = e.BigInt(1e3),
  s = e.BigInt(0),
  f = e.BigInt(1),
  p = e.BigInt(5),
  l = e.BigInt(997),
  d = e.BigInt(1e3)
function m(t, e) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(
        t,
        'symbol' ==
          typeof (o = (function(t, e) {
            if ('object' != typeof t || null === t) return t
            var n = t[Symbol.toPrimitive]
            if (void 0 !== n) {
              var r = n.call(t, 'string')
              if ('object' != typeof r) return r
              throw new TypeError('@@toPrimitive must return a primitive value.')
            }
            return String(t)
          })(r.key))
          ? o
          : String(o),
        r
      )
  }
  var o
}
function h(t, e, n) {
  return e && m(t.prototype, e), n && m(t, n), Object.defineProperty(t, 'prototype', { writable: !1 }), t
}
function y(t, e) {
  ;(t.prototype = Object.create(e.prototype)), (t.prototype.constructor = t), A(t, e)
}
function v(t) {
  return (v = Object.setPrototypeOf
    ? Object.getPrototypeOf.bind()
    : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
      })(t)
}
function A(t, e) {
  return (A = Object.setPrototypeOf
    ? Object.setPrototypeOf.bind()
    : function(t, e) {
        return (t.__proto__ = e), t
      })(t, e)
}
function T() {
  if ('undefined' == typeof Reflect || !Reflect.construct) return !1
  if (Reflect.construct.sham) return !1
  if ('function' == typeof Proxy) return !0
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
  } catch (t) {
    return !1
  }
}
function q(t, e, n) {
  return (q = T()
    ? Reflect.construct.bind()
    : function(t, e, n) {
        var r = [null]
        r.push.apply(r, e)
        var o = new (Function.bind.apply(t, r))()
        return n && A(o, n.prototype), o
      }).apply(null, arguments)
}
function k(t) {
  var e = 'function' == typeof Map ? new Map() : void 0
  return (k = function(t) {
    if (null === t || -1 === Function.toString.call(t).indexOf('[native code]')) return t
    if ('function' != typeof t) throw new TypeError('Super expression must either be null or a function')
    if (void 0 !== e) {
      if (e.has(t)) return e.get(t)
      e.set(t, n)
    }
    function n() {
      return q(t, arguments, v(this).constructor)
    }
    return (
      (n.prototype = Object.create(t.prototype, {
        constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 }
      })),
      A(n, t)
    )
  })(t)
}
function b(t) {
  if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return t
}
function g(t, e) {
  ;(null == e || e > t.length) && (e = t.length)
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n]
  return r
}
function w(t, e) {
  var n = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator']
  if (n) return (n = n.call(t)).next.bind(n)
  if (
    Array.isArray(t) ||
    (n = (function(t, e) {
      if (t) {
        if ('string' == typeof t) return g(t, void 0)
        var n = Object.prototype.toString.call(t).slice(8, -1)
        return (
          'Object' === n && t.constructor && (n = t.constructor.name),
          'Map' === n || 'Set' === n
            ? Array.from(t)
            : 'Arguments' === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
            ? g(t, void 0)
            : void 0
        )
      }
    })(t)) ||
    (e && t && 'number' == typeof t.length)
  ) {
    n && (t = n)
    var r = 0
    return function() {
      return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] }
    }
  }
  throw new TypeError(
    'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
  )
}
var x = 'setPrototypeOf' in Object,
  I = (function(t) {
    function e() {
      var n
      return (
        ((n = t.call(this) || this).isInsufficientReservesError = !0),
        (n.name = n.constructor.name),
        x && Object.setPrototypeOf(b(n), (this instanceof e ? this.constructor : void 0).prototype),
        n
      )
    }
    return y(e, t), e
  })(k(Error)),
  O = (function(t) {
    function e() {
      var n
      return (
        ((n = t.call(this) || this).isInsufficientInputAmountError = !0),
        (n.name = n.constructor.name),
        x && Object.setPrototypeOf(b(n), (this instanceof e ? this.constructor : void 0).prototype),
        n
      )
    }
    return y(e, t), e
  })(k(Error)),
  E = (function() {
    function t(e, r) {
      var o = e.currency.sortsBefore(r.currency) ? [e, r] : [r, e]
      ;(this.liquidityToken = new n.Token(
        o[0].currency.chainId,
        t.getAddress(o[0].currency, o[1].currency),
        18,
        'UNI-V2',
        'Uniswap V2'
      )),
        (this.tokenAmounts = o)
    }
    t.getAddress = function(t, e) {
      return (function(t) {
        var e = t.factoryAddress,
          n = t.tokenA,
          r = t.tokenB,
          i = n.sortsBefore(r) ? [n, r] : [r, n],
          c = i[0]
        return u.getCreate2Address(
          e,
          o.keccak256(['bytes'], [o.pack(['address', 'address'], [c.address, i[1].address])]),
          a[c.chainId]
        )
      })({ factoryAddress: i[t.chainId], tokenA: t, tokenB: e })
    }
    var m = t.prototype
    return (
      (m.involvesToken = function(t) {
        return t.equals(this.token0) || t.equals(this.token1)
      }),
      (m.priceOf = function(t) {
        return this.involvesToken(t) || r(!1), t.equals(this.token0) ? this.token0Price : this.token1Price
      }),
      (m.reserveOf = function(t) {
        return this.involvesToken(t) || r(!1), t.equals(this.token0) ? this.reserve0 : this.reserve1
      }),
      (m.getOutputAmount = function(o) {
        if (
          (this.involvesToken(o.currency) || r(!1),
          e.equal(this.reserve0.quotient, s) || e.equal(this.reserve1.quotient, s))
        )
          throw new I()
        var u = this.reserveOf(o.currency),
          i = this.reserveOf(o.currency.equals(this.token0) ? this.token1 : this.token0),
          a = e.multiply(o.quotient, l),
          c = e.multiply(a, i.quotient),
          f = e.add(e.multiply(u.quotient, d), a),
          p = n.CurrencyAmount.fromRawAmount(o.currency.equals(this.token0) ? this.token1 : this.token0, e.divide(c, f))
        if (e.equal(p.quotient, s)) throw new O()
        return [p, new t(u.add(o), i.subtract(p))]
      }),
      (m.getInputAmount = function(o) {
        if (
          (this.involvesToken(o.currency) || r(!1),
          e.equal(this.reserve0.quotient, s) ||
            e.equal(this.reserve1.quotient, s) ||
            e.greaterThanOrEqual(o.quotient, this.reserveOf(o.currency).quotient))
        )
          throw new I()
        var u = this.reserveOf(o.currency),
          i = this.reserveOf(o.currency.equals(this.token0) ? this.token1 : this.token0),
          a = e.multiply(e.multiply(i.quotient, o.quotient), d),
          c = e.multiply(e.subtract(u.quotient, o.quotient), l),
          p = n.CurrencyAmount.fromRawAmount(
            o.currency.equals(this.token0) ? this.token1 : this.token0,
            e.add(e.divide(a, c), f)
          )
        return [p, new t(i.add(p), u.subtract(o))]
      }),
      (m.getLiquidityMinted = function(t, o, u) {
        t.currency.equals(this.liquidityToken) || r(!1)
        var i,
          a = o.currency.sortsBefore(u.currency) ? [o, u] : [u, o]
        if (((a[0].currency.equals(this.token0) && a[1].currency.equals(this.token1)) || r(!1), e.equal(t.quotient, s)))
          i = e.subtract(n.sqrt(e.multiply(a[0].quotient, a[1].quotient)), c)
        else {
          var f = e.divide(e.multiply(a[0].quotient, t.quotient), this.reserve0.quotient),
            p = e.divide(e.multiply(a[1].quotient, t.quotient), this.reserve1.quotient)
          i = e.lessThanOrEqual(f, p) ? f : p
        }
        if (!e.greaterThan(i, s)) throw new O()
        return n.CurrencyAmount.fromRawAmount(this.liquidityToken, i)
      }),
      (m.getLiquidityValue = function(t, o, u, i, a) {
        var c
        if (
          (void 0 === i && (i = !1),
          this.involvesToken(t) || r(!1),
          o.currency.equals(this.liquidityToken) || r(!1),
          u.currency.equals(this.liquidityToken) || r(!1),
          e.lessThanOrEqual(u.quotient, o.quotient) || r(!1),
          i)
        ) {
          a || r(!1)
          var f = e.BigInt(a)
          if (e.equal(f, s)) c = o
          else {
            var l = n.sqrt(e.multiply(this.reserve0.quotient, this.reserve1.quotient)),
              d = n.sqrt(f)
            if (e.greaterThan(l, d)) {
              var m = e.multiply(o.quotient, e.subtract(l, d)),
                h = e.add(e.multiply(l, p), d),
                y = e.divide(m, h)
              c = o.add(n.CurrencyAmount.fromRawAmount(this.liquidityToken, y))
            } else c = o
          }
        } else c = o
        return n.CurrencyAmount.fromRawAmount(
          t,
          e.divide(e.multiply(u.quotient, this.reserveOf(t).quotient), c.quotient)
        )
      }),
      h(t, [
        {
          key: 'token0Price',
          get: function() {
            var t = this.tokenAmounts[1].divide(this.tokenAmounts[0])
            return new n.Price(this.token0, this.token1, t.denominator, t.numerator)
          }
        },
        {
          key: 'token1Price',
          get: function() {
            var t = this.tokenAmounts[0].divide(this.tokenAmounts[1])
            return new n.Price(this.token1, this.token0, t.denominator, t.numerator)
          }
        },
        {
          key: 'chainId',
          get: function() {
            return this.token0.chainId
          }
        },
        {
          key: 'token0',
          get: function() {
            return this.tokenAmounts[0].currency
          }
        },
        {
          key: 'token1',
          get: function() {
            return this.tokenAmounts[1].currency
          }
        },
        {
          key: 'reserve0',
          get: function() {
            return this.tokenAmounts[0]
          }
        },
        {
          key: 'reserve1',
          get: function() {
            return this.tokenAmounts[1]
          }
        }
      ]),
      t
    )
  })(),
  P = (function() {
    function t(t, e, n) {
      ;(this._midPrice = null), t.length > 0 || r(!1)
      var o = t[0].chainId
      t.every(function(t) {
        return t.chainId === o
      }) || r(!1)
      var u = e.wrapped
      t[0].involvesToken(u) || r(!1), void 0 === n || t[t.length - 1].involvesToken(n.wrapped) || r(!1)
      for (var i, a = [u], c = w(t.entries()); !(i = c()).done; ) {
        var s = i.value,
          f = s[1],
          p = a[s[0]]
        p.equals(f.token0) || p.equals(f.token1) || r(!1)
        var l = p.equals(f.token0) ? f.token1 : f.token0
        a.push(l)
      }
      ;(this.pairs = t), (this.path = a), (this.input = e), (this.output = n)
    }
    return (
      h(t, [
        {
          key: 'midPrice',
          get: function() {
            if (null !== this._midPrice) return this._midPrice
            for (var t, e = [], r = w(this.pairs.entries()); !(t = r()).done; ) {
              var o = t.value,
                u = o[1]
              e.push(
                this.path[o[0]].equals(u.token0)
                  ? new n.Price(u.reserve0.currency, u.reserve1.currency, u.reserve0.quotient, u.reserve1.quotient)
                  : new n.Price(u.reserve1.currency, u.reserve0.currency, u.reserve1.quotient, u.reserve0.quotient)
              )
            }
            var i = e.slice(1).reduce(function(t, e) {
              return t.multiply(e)
            }, e[0])
            return (this._midPrice = new n.Price(this.input, this.output, i.denominator, i.numerator))
          }
        },
        {
          key: 'chainId',
          get: function() {
            return this.pairs[0].chainId
          }
        }
      ]),
      t
    )
  })()
function C(t, e) {
  var n = (function(t, e) {
    return (
      t.inputAmount.currency.equals(e.inputAmount.currency) || r(!1),
      t.outputAmount.currency.equals(e.outputAmount.currency) || r(!1),
      t.outputAmount.equalTo(e.outputAmount)
        ? t.inputAmount.equalTo(e.inputAmount)
          ? 0
          : t.inputAmount.lessThan(e.inputAmount)
          ? -1
          : 1
        : t.outputAmount.lessThan(e.outputAmount)
        ? 1
        : -1
    )
  })(t, e)
  return 0 !== n
    ? n
    : t.priceImpact.lessThan(e.priceImpact)
    ? -1
    : t.priceImpact.greaterThan(e.priceImpact)
    ? 1
    : t.route.path.length - e.route.path.length
}
var _ = (function() {
  function t(t, e, o) {
    ;(this.route = t), (this.tradeType = o)
    var u = new Array(t.path.length)
    if (o === n.TradeType.EXACT_INPUT) {
      e.currency.equals(t.input) || r(!1), (u[0] = e.wrapped)
      for (var i = 0; i < t.path.length - 1; i++) {
        var a = t.pairs[i].getOutputAmount(u[i])
        u[i + 1] = a[0]
      }
      ;(this.inputAmount = n.CurrencyAmount.fromFractionalAmount(t.input, e.numerator, e.denominator)),
        (this.outputAmount = n.CurrencyAmount.fromFractionalAmount(
          t.output,
          u[u.length - 1].numerator,
          u[u.length - 1].denominator
        ))
    } else {
      e.currency.equals(t.output) || r(!1), (u[u.length - 1] = e.wrapped)
      for (var c = t.path.length - 1; c > 0; c--) {
        var s = t.pairs[c - 1].getInputAmount(u[c])
        u[c - 1] = s[0]
      }
      ;(this.inputAmount = n.CurrencyAmount.fromFractionalAmount(t.input, u[0].numerator, u[0].denominator)),
        (this.outputAmount = n.CurrencyAmount.fromFractionalAmount(t.output, e.numerator, e.denominator))
    }
    ;(this.executionPrice = new n.Price(
      this.inputAmount.currency,
      this.outputAmount.currency,
      this.inputAmount.quotient,
      this.outputAmount.quotient
    )),
      (this.priceImpact = n.computePriceImpact(t.midPrice, this.inputAmount, this.outputAmount))
  }
  ;(t.exactIn = function(e, r) {
    return new t(e, r, n.TradeType.EXACT_INPUT)
  }),
    (t.exactOut = function(e, r) {
      return new t(e, r, n.TradeType.EXACT_OUTPUT)
    })
  var e = t.prototype
  return (
    (e.minimumAmountOut = function(t) {
      if ((t.lessThan(s) && r(!1), this.tradeType === n.TradeType.EXACT_OUTPUT)) return this.outputAmount
      var e = new n.Fraction(f)
        .add(t)
        .invert()
        .multiply(this.outputAmount.quotient).quotient
      return n.CurrencyAmount.fromRawAmount(this.outputAmount.currency, e)
    }),
    (e.maximumAmountIn = function(t) {
      if ((t.lessThan(s) && r(!1), this.tradeType === n.TradeType.EXACT_INPUT)) return this.inputAmount
      var e = new n.Fraction(f).add(t).multiply(this.inputAmount.quotient).quotient
      return n.CurrencyAmount.fromRawAmount(this.inputAmount.currency, e)
    }),
    (t.bestTradeExactIn = function(e, o, u, i, a, c, f) {
      var p = void 0 === i ? {} : i,
        l = p.maxNumResults,
        d = void 0 === l ? 3 : l,
        m = p.maxHops,
        h = void 0 === m ? 3 : m
      void 0 === a && (a = []),
        void 0 === c && (c = o),
        void 0 === f && (f = []),
        e.length > 0 || r(!1),
        h > 0 || r(!1),
        o === c || a.length > 0 || r(!1)
      for (var y = c.wrapped, v = u.wrapped, A = 0; A < e.length; A++) {
        var T = e[A]
        if (
          (T.token0.equals(y.currency) || T.token1.equals(y.currency)) &&
          !T.reserve0.equalTo(s) &&
          !T.reserve1.equalTo(s)
        ) {
          var q = void 0
          try {
            q = T.getOutputAmount(y)[0]
          } catch (t) {
            if (t.isInsufficientInputAmountError) continue
            throw t
          }
          if (q.currency.equals(v))
            n.sortedInsert(f, new t(new P([].concat(a, [T]), o.currency, u), o, n.TradeType.EXACT_INPUT), d, C)
          else if (h > 1 && e.length > 1) {
            var k = e.slice(0, A).concat(e.slice(A + 1, e.length))
            t.bestTradeExactIn(k, o, u, { maxNumResults: d, maxHops: h - 1 }, [].concat(a, [T]), q, f)
          }
        }
      }
      return f
    }),
    (e.worstExecutionPrice = function(t) {
      return new n.Price(
        this.inputAmount.currency,
        this.outputAmount.currency,
        this.maximumAmountIn(t).quotient,
        this.minimumAmountOut(t).quotient
      )
    }),
    (t.bestTradeExactOut = function(e, o, u, i, a, c, f) {
      var p = void 0 === i ? {} : i,
        l = p.maxNumResults,
        d = void 0 === l ? 3 : l,
        m = p.maxHops,
        h = void 0 === m ? 3 : m
      void 0 === a && (a = []),
        void 0 === c && (c = u),
        void 0 === f && (f = []),
        e.length > 0 || r(!1),
        h > 0 || r(!1),
        u === c || a.length > 0 || r(!1)
      for (var y = c.wrapped, v = o.wrapped, A = 0; A < e.length; A++) {
        var T = e[A]
        if (
          (T.token0.equals(y.currency) || T.token1.equals(y.currency)) &&
          !T.reserve0.equalTo(s) &&
          !T.reserve1.equalTo(s)
        ) {
          var q = void 0
          try {
            q = T.getInputAmount(y)[0]
          } catch (t) {
            if (t.isInsufficientReservesError) continue
            throw t
          }
          if (q.currency.equals(v))
            n.sortedInsert(f, new t(new P([T].concat(a), o, u.currency), u, n.TradeType.EXACT_OUTPUT), d, C)
          else if (h > 1 && e.length > 1) {
            var k = e.slice(0, A).concat(e.slice(A + 1, e.length))
            t.bestTradeExactOut(k, o, u, { maxNumResults: d, maxHops: h - 1 }, [T].concat(a), q, f)
          }
        }
      }
      return f
    }),
    t
  )
})()
function B(t) {
  return '0x' + t.quotient.toString(16)
}
var F = (function() {
  function t() {}
  return (
    (t.swapCallParameters = function(t, e) {
      var o = t.inputAmount.currency.isNative,
        u = t.outputAmount.currency.isNative
      o && u && r(!1), !('ttl' in e) || e.ttl > 0 || r(!1)
      var i,
        a,
        c,
        s = n.validateAndParseAddress(e.recipient),
        f = B(t.maximumAmountIn(e.allowedSlippage)),
        p = B(t.minimumAmountOut(e.allowedSlippage)),
        l = t.route.path.map(function(t) {
          return t.address
        }),
        d =
          'ttl' in e
            ? '0x' + (Math.floor(new Date().getTime() / 1e3) + e.ttl).toString(16)
            : '0x' + e.deadline.toString(16),
        m = Boolean(e.feeOnTransfer)
      switch (t.tradeType) {
        case n.TradeType.EXACT_INPUT:
          o
            ? ((i = m ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'),
              (a = [p, l, s, d]),
              (c = f))
            : u
            ? ((i = m ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'),
              (a = [f, p, l, s, d]),
              (c = '0x0'))
            : ((i = m ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens'),
              (a = [f, p, l, s, d]),
              (c = '0x0'))
          break
        case n.TradeType.EXACT_OUTPUT:
          m && r(!1),
            o
              ? ((i = 'swapETHForExactTokens'), (a = [p, l, s, d]), (c = f))
              : u
              ? ((i = 'swapTokensForExactETH'), (a = [p, f, l, s, d]), (c = '0x0'))
              : ((i = 'swapTokensForExactTokens'), (a = [p, f, l, s, d]), (c = '0x0'))
      }
      return { methodName: i, args: a, value: c }
    }),
    t
  )
})()
;(exports.FACTORY_ADDRESS = i),
  (exports.INIT_CODE_HASH = a),
  (exports.InsufficientInputAmountError = O),
  (exports.InsufficientReservesError = I),
  (exports.MINIMUM_LIQUIDITY = c),
  (exports.Pair = E),
  (exports.Route = P),
  (exports.Router = F),
  (exports.Trade = _)
//# sourceMappingURL=v2-sdk.cjs.production.min.js.map
